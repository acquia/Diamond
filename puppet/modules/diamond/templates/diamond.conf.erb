<%-

metrics = [
  {
    :collector => 'CassandraCollector',
      :objects => 
      [
        {
        :object_name => 'org.apache.cassandra.db:type=CompactionManager',
        :attributes => ['TotalBytesCompacted','TotalCompactionsCompleted','CompletedTasks','PendingTasks']
        },
        {
          :object_name => 'org.apache.cassandra.db:type=ColumnFamilies,keyspace=system,columnfamily=peers',
          :attributes => ['TotalDiskSpaceUsed',]
        },
        {
          :object_name => 'org.apache.cassandra.db:type=Caches',
          :attributes => ['KeyCacheHits','RowCacheHits','KeyCacheRequests','RowCacheRequests','KeyCacheEntries','KeyCacheSize'],
        },
        {
          :object_name => 'org.apache.cassandra.db:type=ColumnFamilies,keyspace=system,columnfamily=IndexInfo',
          :attributes => ['LiveSSTableCount','TotalDiskSpaceUsed','TotalReadLatencyMicros','TotalWriteLatencyMicros'],
        },
        {
          :object_name => 'org.apache.cassandra.db:type=StorageProxy',
          :attributes => ['WriteOperations','ReadOperations']
        },
      ]
  },
  {
    :collector => 'MemoryCollector',
    :metric_names => ["Memtotal","MemFree"],
    :path => 'memory'
  },
  {
    :collector => 'CPUCollector',
    :metric_names => ["total.iowait", "total.steal", "total.guest", "total.system", "total.user", "total.nice", "total.idle", "total.softirq", "total.irq"],
    :normalize => 'False',
    :percore => 'False',
    :path => 'cpu'
  },
  {
    :collector => 'DiskSpaceCollector',
    :metric_names => ["_mnt.byte_percentfree", "_mnt.inodes_percentfree","root.byte_percentfree", "root.inodes_percentfree"],
    :byte_unit => 'megabyte',
    :path => 'diskspace'
  }
]

def cloudwatch_handler_options(section_name,collector_path, metric, name, unit="None", namespace="NemesisMetrics")
  cw_metrics = "\n"
  cw_metrics += "[[[#{section_name}]]]\n"
  cw_metrics += "collector = #{collector_path}\n"
  cw_metrics += "metric = '#{metric}'\n"
  cw_metrics += "namespace = #{namespace}\n"
  cw_metrics += "name = '#{name}'\n"
  cw_metrics += "unit = #{unit}\n"
  cw_metrics
end

collectors_config = ""
cw_handler_config = ""

metrics.each_with_index do |source, sindex|
  case source[:collector]
  when 'CassandraCollector'
    collectors_config += "\n[[#{source[:collector]}]]\n"
    collectors_config += "enabled = True\n"
    collectors_config += "[[[jmx_objects]]]\n"
    source[:objects].each_with_index do |object, oindex|
      object_name = object[:object_name]
      attrs = object[:attributes].map{|o| "'#{o}'"}.join(',')

      collectors_config += "[[[[#{object_name}]]]]\n"
      collectors_config += "object_name = '#{object_name}'\n"
      collectors_config += "attributes = #{attrs},\n"

      object[:attributes].each_with_index do |attribute, aindex|
        metric_name = object_name + "." + attribute
        cw_handler_config += cloudwatch_handler_options("metric_#{sindex}#{oindex}#{aindex}", "CassandraCollector", "metric.#{metric_name}", metric_name)
      end
    end
  when 'CPUCollector'
    # collector config
    collectors_config += "\n[[#{source[:collector]}]]\n"
    collectors_config += "percore = #{source[:percore]}\n"
    collectors_config += "normalize = #{source[:normalize]}\n"
    collectors_config += "path = '#{source[:path]}'\n"
    # handler config
    if source[:metric_names]
      source[:metric_names].each_with_index do |metric_name, oindex|
        cw_handler_config += cloudwatch_handler_options("metric_#{sindex}#{oindex}", source[:path], metric_name, metric_name)
      end
    end
  when 'DiskSpaceCollector'
    # collector config
    collectors_config += "\n[[#{source[:collector]}]]\n"
    collectors_config += "byte_unit = #{source[:byte_unit]}\n"
    collectors_config += "path = '#{source[:path]}'\n"
    # handler config
    if source[:metric_names]
      source[:metric_names].each_with_index do |metric_name, oindex|
        cw_handler_config += cloudwatch_handler_options("metric_#{sindex}#{oindex}", source[:path], metric_name, metric_name)
      end
    end
  else
    collectors_config += "\n[[#{source[:collector]}]]\n"
    collectors_config += "enabled = True\n"
    collectors_config += "path = '#{source[:path]}'\n"
    if source[:metric_names]
      source[:metric_names].each_with_index do |metric_name, oindex|
        cw_handler_config += cloudwatch_handler_options("metric_#{sindex}#{oindex}", source[:path], metric_name, metric_name)
      end
    end
  end
end
-%>
################################################################################
# Diamond Configuration File
################################################################################

################################################################################
### Options for the server
[server]

# Handlers for published metrics.
handlers = diamond.handler.archive.ArchiveHandler, diamond.handler.cloudwatch.cloudwatchHandler

# User diamond will run as
# Leave empty to use the current user
user = diamond

# Group diamond will run as
# Leave empty to use the current group
group = diamond

# Pid file
pid_file = /var/run/diamond.pid

# Directory to load collector modules from
collectors_path = /usr/share/diamond/collectors/

# Directory to load collector configs from
collectors_config_path = /etc/diamond/collectors/

# Directory to load handler configs from
handlers_config_path = /etc/diamond/handlers/

handlers_path = /usr/share/diamond/handlers/

# Interval to reload collectors
collectors_reload_interval = 3600

################################################################################
### Options for handlers
[handlers]

# daemon logging handler(s)
keys = rotated_file

### Defaults options for all Handlers
[[default]]

[[cloudwatchHandler]]

region = <%=Nemesis::Aws.region_from_az(@ec2_placement_availability_zone)%>

# Generic CloudWatch metrics
<%=cw_handler_config%>

[[ArchiveHandler]]

# File to write archive log files
log_file = /var/log/diamond/archive.log

# Number of days to keep archive log files
days = 7

################################################################################
### Options for collectors
[collectors]

[[default]]
### Defaults options for all Collectors

# Uncomment and set to hardcode a hostname for the collector path
# Keep in mind, periods are seperators in graphite
# hostname = my_custom_hostname

# If you prefer to just use a different way of calculating the hostname
# Uncomment and set this to one of these values:

# smart = Default. Tries fqdn_short. If that's localhost, uses hostname_short

# fqdn_short = Default. Similar to hostname -s
# fqdn = hostname output
# fqdn_rev = hostname in reverse (com.example.www)

# uname_short = Similar to uname -n, but only the first part
# uname_rev = uname -r in reverse (com.example.www)

# hostname_short = `hostname -s`
# hostname = `hostname`
# hostname_rev = `hostname` in reverse (com.example.www)

# hostname_method = smart

# Path Prefix and Suffix
# you can use one or both to craft the path where you want to put metrics
# such as: %(path_prefix)s.$(hostname)s.$(path_suffix)s.$(metric)s
# path_prefix = servers
# path_suffix =

# Path Prefix for Virtual Machines
# If the host supports virtual machines, collectors may report per
# VM metrics. Following OpenStack nomenclature, the prefix for
# reporting per VM metrics is "instances", and metric foo for VM
# bar will be reported as: instances.bar.foo...
# instance_prefix = instances

# Default Poll Interval (seconds)
# interval = 300

# collectors config
<%=collectors_config%>

################################################################################
### Options for logging
# for more information on file format syntax:
# http://docs.python.org/library/logging.config.html#configuration-file-format

[loggers]

keys = root

# handlers are higher in this config file, in:
# [handlers]
# keys = ...

[formatters]

keys = default

[logger_root]

# to increase verbosity, set DEBUG
level = INFO
handlers = rotated_file
propagate = 1

[handler_rotated_file]

class = handlers.TimedRotatingFileHandler
level = DEBUG
formatter = default
# rotate at midnight, each day and keep 7 days
args = ('/var/log/diamond/diamond.log', 'midnight', 1, 7)

[formatter_default]

format = [%(asctime)s] [%(threadName)s] %(message)s
datefmt =
