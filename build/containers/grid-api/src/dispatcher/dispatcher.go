package dispatcher

import (
	"fmt"
	log "github.com/Sirupsen/logrus"
	scheduler "github.com/acquia/grid-api/dispatcher/scheduler"
	"github.com/acquia/grid-api/thrift"
	"github.com/acquia/grid-api/thrift/manifest"
	"time"
)

type DispatcherAction int

const (
	ACTION_CREATE DispatcherAction = iota
	ACTION_UPDATE
	ACTION_KILL
	ACTION_RESTART
	ACTION_VALIDATE
	ACTION_STATE
	ACTION_UNKNOWN
)

// DispatcherActionString translates DispatcherAction values into strings.
var DispatcherActionString = map[DispatcherAction]string{
	ACTION_CREATE:   "Create",
	ACTION_UPDATE:   "Update",
	ACTION_KILL:     "Kill",
	ACTION_RESTART:  "Restart",
	ACTION_VALIDATE: "Validate",
	ACTION_STATE:    "State",
	ACTION_UNKNOWN:  "UNKNOWN",
}

// ProcessManifest takes a manifest and executes the specified action on the remote scheduler.
func ProcessManifest(action DispatcherAction, jobManifest *manifest.Manifest, config *scheduler.SchedulerConfig, remoteScheduler scheduler.RemoteScheduler) (results []*thrift.JobInfo, err error) {
	applications := jobManifest.Applications

	for _, app := range applications {
		var result *scheduler.SchedulerResult

		switch action {
		case ACTION_CREATE:
			result, err = remoteScheduler.Create(app)
		case ACTION_UPDATE:
			result, err = remoteScheduler.Update(app)
		case ACTION_KILL:
			result, err = remoteScheduler.Kill(app.Id)
		case ACTION_RESTART:
			result, err = remoteScheduler.Restart(app.Id)
		case ACTION_VALIDATE:
			// @todo is this a scheduler action or generic?
			//result, err = remoteScheduler.Validate(app.Id)
		case ACTION_STATE:
			// @todo finish the aurora State() action.
			//result, err = remoteScheduler.State(app.Id)
		}

		if err == nil && result != nil {
			info := convertSchedulerResultToJobInfo(app.Id, result)

			results = append(results, info)
		} else {
			timestamp := time.Now().UnixNano()
			message := fmt.Sprintf("An unknown error occured executing action %s", DispatcherActionString[action])
			log.Error(message)
			info := &thrift.JobInfo{
				Id:      app.Id,
				Time:    timestamp,
				Message: message,
			}
			results = append(results, info)
		}

		// @todo does it really make sense to kill?
		// If an error occurrs along the way then then terminate all jobs and return the result
		// @todo: add roll back capabilities for update case
		//if action == ACTION_CREATE && err != nil {
		//	log.Error(err)
		//	for _, app := range applications {
		//		log.Error("Killing %+v", app.Id)
		//		result, err = remoteScheduler.Kill(app.Id, config)
		//		results = append(results, result)
		//	}

		//	return results, err
		//}
	}

	return results, err
}

// convertSchedulerResultToJobInfo converts a SchedulerResult into a JobInfo to return to the client.
func convertSchedulerResultToJobInfo(id *manifest.AppID, result *scheduler.SchedulerResult) *thrift.JobInfo {
	timestamp := time.Now().UnixNano()
	info := &thrift.JobInfo{
		Id:      id,
		Time:    timestamp,
		Message: result.Output,
	}

	return info
}

// NewMockManifest produces a mock manifest that can be used for testing.
// This belongs in the manifest file, but since that is generated by Thrift
// and we need this in multiple places for testing, this is the most convenient
// location.
func NewMockManifest() *manifest.Manifest {
	mock := manifest.NewManifest()
	mock.Id = manifest.NewManifestID()
	mock.Id.Name = "Id.Name"
	mock.Id.Role = "Id.Role"
	mock.Id.Environment = "Id.Environment"

	app := manifest.NewApplication()
	app.Id = manifest.NewAppID()
	app.Id.Name = "Application.Id.Name"
	app.Id.Role = "Application.Id.Role"
	app.Id.Environment = "Application.Id.Environment"
	app.AppConfig = manifest.NewAppConfig()
	app.AppConfig.AppType = manifest.AppType_TASK
	app.AppConfig.SourceType = manifest.AppSourceType_DOCKER
	app.AppConfig.Source = "Application.AppConfig.Source"
	// @todo add in docker parameters and test.
	app.AppConfig.Command = "Application.AppConfig.Command"
	app.AppConfig.Production = true
	cron_schedule := "Application.AppConfig.CronSchedule"
	app.AppConfig.CronSchedule = &cron_schedule
	app.Resources = manifest.NewResources()
	app.Resources.Cpu = 1
	app.Resources.Ram = 1000
	app.Resources.Disk = manifest.NewDisk()
	app.Resources.Disk.Size = 1000
	app.Copies = manifest.NewCopies()
	app.Copies.Max = 1
	app.HealthCheck = manifest.NewHealthCheck()
	app.UpdateConfig = manifest.NewUpdateConfig()

	mock.Applications = make([]*manifest.Application, 1)
	mock.Applications[0] = app

	return mock
}
