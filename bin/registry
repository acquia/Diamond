#!/usr/bin/env ruby
#
# Copyright 2015 Acquia, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Utility to manage a remote docker registry used to host containers built for nemesis-puppet
#

require 'aws-sdk'
require 'base64'
require 'thor'

def ecs_docker_info(authorization_token)
  data = authorization_token.authorization_data.first
  user, token = Base64.decode64(data.authorization_token).split(':')
  endpoint = data.proxy_endpoint

  {
    :user => user,
    :token => token,
    :endpoint => endpoint.gsub!(/^https:\/\//, '')
  }
end

class RegistryManager < Thor
  desc "push container", "Push a docker container to the remote registry"
  method_option :tag, :aliases => '-t', :type => :string, :default => 'latest', :desc => "Container image tag. [Default: 'latest']"
  method_option :stage, :type => :string, :default => ENV['USER'], :desc => "Stage prefix for the repository. [Default: '#{ENV['USER']}']"
  def push(container)
    client = Aws::ECR::Client.new
    stage = options[:stage]
    tag = options[:tag]

    authorization_token = client.get_authorization_token
    auth_info = ecs_docker_info(authorization_token)
    endpoint = auth_info[:endpoint]

    `docker login -u #{auth_info[:user]} -p #{auth_info[:token]} -e none https://#{endpoint}`
    if $?.exitstatus != 0
      puts "Error logging into docker registry: #{endpoint}"
      exit 1
    end

    begin
      client.create_repository({
        repository_name: "#{stage}/#{container}"
      })
    rescue Aws::ECR::Errors::RepositoryAlreadyExistsException
    end

    puts "Tagging Container: #{container}:#{tag} #{endpoint}/#{stage}/#{container}:#{tag}"
    `docker tag -f #{container}:#{tag} #{endpoint}/#{stage}/#{container}:#{tag}`
    if $?.exitstatus != 0
      puts "Error: unable to tag #{container}:#{tag}"
      exit 1
    end

    puts "Pushing Container: #{endpoint}/#{stage}/#{container}:#{tag}"
    unless system("docker push #{endpoint}/#{stage}/#{container}:#{tag}")
      puts "Error: unable to push container #{endpoint}/#{stage}/#{container}:#{tag}"
      exit 1
    end

    puts "Removing Tag: #{endpoint}/#{stage}/#{container}:#{tag}"
    `docker rmi #{endpoint}/#{stage}/#{container}:#{tag}`
    if $?.exitstatus != 0
      puts "Error: unable to remove tag #{endpoint}/#{stage}/#{container}:#{tag}"
      exit 1
    end
  end

  desc "delete container", "Delete a docker container exiting in a remote registry."
  method_option :tag, :aliases => '-t', :type => :string, :default => 'latest', :desc => "Container image tag. [Default: 'latest']"
  method_option :stage, :type => :string, :default => ENV['USER'], :desc => "Stage prefix for the repository. [Default: '#{ENV['USER']}']"
  method_option :force, :aliases => '-f', :type => :boolean, :default => false, :desc => "Delete the entire repository for the given container. [Default: false]"
  def delete(container)
    client = Aws::ECR::Client.new
    stage = options[:stage]
    tag = options[:tag]

    if options[:force] == true
      client.delete_repository({
        repository_name: "#{stage}/#{container}",
        force: true,
      })
    else
      client.batch_delete_image({
        repository_name: "#{stage}/#{container}",
        image_ids: [
          {
            image_tag: tag,
          },
        ],
      })
    end
  end
end

# Ensure that Aws credentials are in place
begin
  creds ||= ENV['AWS_PROFILE'] ? Aws::SharedCredentials.new.credentials : Aws::S3::Client.new.config.credentials
  unless creds
    puts 'Error: You must configure AWS access credentials.'
    exit 1
  end
rescue Aws::Errors::MissingRegionError => e
  puts "Error: #{e.message}"
  exit 1
end

RegistryManager.start(ARGV)
