#!/usr/bin/env ruby
#
# Copyright 2015 Acquia, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Utility to manage creating a rpm repository from packages built for nemesis-puppet
#

require 'aws-sdk'
require 'thor'


# @return [Aws::Credentials] Currently set Aws credentials, or nil if they are not set.
def aws_creds
  @creds ||= ENV['AWS_PROFILE'] ? Aws::SharedCredentials.new.credentials : Aws::S3::Client.new.config.credentials
end

def docker_aws_creds
  "-e AWS_ACCESS_KEY_ID='#{aws_creds.credentials.access_key_id}' -e AWS_SECRET_ACCESS_KEY='#{aws_creds.credentials.secret_access_key}'"
end

class RepoManager < Thor
  class_option :nemesis_container_name, :type => :string, :default => "nemesis-puppet-volumes", :desc =>"Name of the volume that docker containers would share"
  desc "create", "Initialize and create a package repository."
  def create
    check_dependencies(options[:nemesis_container_name])
    unless system("docker run -i --rm --volumes-from #{options[:nemesis_container_name]} acquia/rpm_repo:latest")
      puts "Error: unable to create repo."
      exit 1
    end
    puts "Repo created successfully"
  end

  desc "delete STACKNAME", "Delete a package repository."
  def delete(stackname)
    check_dependencies(options[:nemesis_container_name])
    purge_repo_directory(options[:nemesis_container_name])

    bucket = get_s3_bootstrap_repo_bucket(stackname)
    cmd = "docker run -i --rm #{docker_aws_creds()} --volumes-from #{options[:nemesis_container_name]} tools/aws s3 rm --recursive s3://#{bucket}/repo"
    system(cmd)
  end


  desc "upload STACKNAME", "Upload a package repository."
  def upload(stackname)
    check_dependencies(options[:nemesis_container_name])
    bucket = get_s3_bootstrap_repo_bucket(stackname)
    cmd = "docker run -i --rm #{docker_aws_creds()} --volumes-from #{options[:nemesis_container_name]} tools/aws s3 sync --delete /dist s3://#{bucket}"
    system(cmd)
  end

  desc "download STACKNAME", "Download a package repository."
  def download(stackname)
    check_dependencies(options[:nemesis_container_name])
    purge_repo_directory(options[:nemesis_container_name])

    cmd = "docker run -i --rm #{docker_aws_creds()} --volumes-from #{options[:nemesis_container_name]} tools/aws s3 sync --delete /dist"
    system(cmd)
  end

  no_tasks do
    def check_dependencies(container_name)
      unless system("docker ps -a --filter='name=#{container_name}' | grep '#{container_name}' 1>/dev/null")
        puts "Container #{container_name} is not available. Run `build -b` to bootstrap necessary dependencies."
        exit 1
      end
    end

    def purge_repo_directory(container_name)
       unless system("docker run -i --rm #{docker_aws_creds()} --volumes-from #{container_name} --entrypoint /bin/bash tools/aws rm -rf /dist/repo")
        puts "Error: unable to remove existing repo directory"
        exit 1
      end
    end

    def get_s3_bootstrap_repo_bucket(repo_stackname)
      Aws::CloudFormation::Resource.new.stack(repo_stackname).resource('repo').physical_resource_id
    end

  end
end


begin
  unless aws_creds
    puts 'Error: You must configure AWS access credentials.'
    exit 1
  end
rescue Aws::Errors::MissingRegionError => e
  puts "Error: #{e.message}"
  exit 1
end

RepoManager.start(ARGV)
