#!/usr/bin/env ruby
#
# Copyright 2015 Acquia, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Utility to manage creating a rpm repository from packages built for nemesis-puppet
#

require 'aws-sdk'
require 'fileutils'
require 'pathname'
require 'tempfile'

nemesis_puppet_root = File.expand_path(File.join(Pathname.new(__FILE__).realpath, '..', '..'))
dist_root = File.join(nemesis_puppet_root, 'dist')
repo_root = File.join(dist_root, 'repo/')

def get_s3_bootstrap_repo_bucket(repo_stackname)
  Aws::CloudFormation::Resource.new.stack(repo_stackname).resource('repo').physical_resource_id
end

# @return [Aws::Credentials] Currently set Aws credentials, or nil if they are not set.
def aws_creds
  @creds ||= ENV['AWS_PROFILE'] ? Aws::SharedCredentials.new.credentials : Aws::S3::Client.new.config.credentials
end

def docker_aws_creds
  "-e AWS_ACCESS_KEY_ID='#{aws_creds.access_key_id}' -e AWS_SECRET_ACCESS_KEY='#{aws_creds.secret_access_key}'"
end

def create(dist_root)
  gpg_homedir = "#{dist_root}/.gnupg"
  FileUtils.rm_rf(gpg_homedir) if Dir.exists?(gpg_homedir)
  FileUtils.mkdir_p(gpg_homedir)

  default_gpg_key_params= <<PARAMS
Key-Type: RSA
Key-Length: 2048
Name-Real: Acquia Engineering
Name-Email: engineering@acquia.com
Expire-Date: 0
%commit
%echo done
PARAMS

  begin
    gpg_params_file = Tempfile.new('gpg_key_params.conf')
    gpg_params_file.write(default_gpg_key_params)
    gpg_params_file.close
    system("gpg --homedir #{gpg_homedir} --batch --gen-key #{gpg_params_file.path}")
  ensure
     gpg_params_file.unlink
  end

  container_id=`docker run -d -v #{dist_root}:/dist acquia/rpm_repo:latest`
  exit_code=`docker wait #{container_id}`.to_i
  system("docker rm -f #{container_id}")

  if exit_code != 0
    puts "Error: unable to create repo, exited with code #{exit_code}"
    exit 1
  end
  puts "Repository created at: #{dist_root}/repo"
end

def delete(repo_root, stackname)
  system("rm -rf #{repo_root}")

  bucket = get_s3_bootstrap_repo_bucket(stackname)

  if system('which aws')
    cmd = "aws s3 rm --recursive s3://#{bucket}/repo"
  else
    cmd = "docker run -i --rm #{docker_aws_creds()} -v #{repo_root}:/dist tools/aws-cli aws s3 rm --recursive s3://#{bucket}/repo"
  end
  system(cmd)
end

def upload(repo_root, stackname)
  bucket = get_s3_bootstrap_repo_bucket(stackname)

  if system('which aws')
    cmd = "aws s3 sync --delete #{repo_root}/repo s3://#{bucket}/repo"
  else
    cmd = "docker run -i --rm #{docker_aws_creds()} -v #{repo_root}/repo:/dist tools/aws-cli aws s3 sync --delete /dist s3://#{bucket}/repo "
  end
  system(cmd)
end

def download(repo_root, stackname)
  bucket = get_s3_bootstrap_repo_bucket(stackname)

  system("rm -rf #{repo_root}")

  if system('which aws')
    cmd = "aws s3 sync --delete s3://#{bucket}/repo #{repo_root}"
  else
    cmd = "docker run -i --rm #{docker_aws_creds()} -v #{repo_root}:/dist tools/aws-cli aws s3 sync --delete s3://#{bucket}/repo /dist"
  end
  system(cmd)
end

def print_usage_and_exit
  puts 'Usage: repo [ACTION] [REPO] [OPTION]'
  exit(1)
end

action = ARGV.shift
stackname = ''

print_usage_and_exit if action.nil?

unless action == 'create'
  begin
    unless aws_creds
      puts 'Error: You must configure AWS access credentials.'
      exit 1
    end
  rescue Aws::Errors::MissingRegionError => e
    puts "Error: #{e.message}"
    exit 1
  end
  stackname = ARGV.shift
end

case action.downcase
when 'create'
  create(dist_root)
when 'delete'
  delete(repo_root, stackname)
when 'upload'
  upload(dist_root, stackname)
when 'download'
  download(dist_root, stackname)
else
  print_usage_and_exit
end
